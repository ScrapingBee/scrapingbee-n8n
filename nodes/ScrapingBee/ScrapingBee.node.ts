import {
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeOperationError,
	NodeConnectionType,
	INodeInputConfiguration,
	INodeOutputConfiguration,
	IHttpRequestOptions
} from 'n8n-workflow';

export class ScrapingBee implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'ScrapingBee',
		// eslint-disable-next-line n8n-nodes-base/node-class-description-name-miscased
		name: 'ScrapingBee',
		icon: 'file:scrapingbee.svg',
		group: ['transform'],
		version: 1,
		subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
		description: 'Scrape websites using ScrapingBee',
		defaults: {
			name: 'ScrapingBee',
		},
		inputs: ['main'] as (NodeConnectionType | INodeInputConfiguration)[],
		outputs: ['main'] as (NodeConnectionType | INodeOutputConfiguration)[],
		credentials: [
			{
				name: 'ScrapingBeeApi',
				required: true,
			},
		],
		properties: [
			{
				displayName: 'Resource',
				name: 'resource',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'HTML API',
						value: 'htmlAPI',
					},
					{
						name: 'Google Search API',
						value: 'googleSearchAPI',
					},
					{
						name: 'Usage',
						value: 'usage',
					},
				],
				default: 'htmlAPI',
			},
			// Operations for HTML API
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['htmlAPI'],
					},
				},
				options: [
					{
						name: 'GET',
						value: 'get',
						action: 'Scrape using HTML API',
						description: 'Scrape the webpage using our HTML API',
					},
					{
						name: 'POST',
						value: 'post',
						action: 'Send POST request using HTML API',
						description: 'Send a post request using our HTML API',
					},
					{
						name: 'PUT',
						value: 'put',
						action: 'Send PUT request using HTML API',
						description: 'Send a put request using our HTML API',
					},
				],
				default: 'get',
			},
			// Operation for Google Search API
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['googleSearchAPI'],
					},
				},
				options: [
					{
						name: 'GET',
						value: 'get',
						action: 'Get SERP data using GOOGLE SEARCH API',
						description: 'Get SERP data using our Google Search API',
					},
				],
				default: 'get',
			},
			// Operation for Usage
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				displayOptions: {
					show: {
						resource: ['usage'],
					},
				},
				options: [
					{
						name: 'GET',
						value: 'get',
						action: 'Get usage data',
						description: 'Get your API usage data',
					},
				],
				default: 'get',
			},
			{
				displayName: 'URL',
				description: 'Target webpage to scrape',
				required: true,
				name: 'url',
				type: 'string',
				default: 'http://httpbin.org/anything?json',
				displayOptions: {
					show: {
						resource: ['htmlAPI'],
					},
				},
			},
			{
				displayName: 'Forward Headers',
				name: 'forwardHeaders',
				type: 'boolean',
				default: false,
				description: 'Whether to forward particular headers to the webpage, as well as other headers generated by ScrapingBee or not',
				displayOptions: {
					show: {
						resource: ['htmlAPI'],
					},
				},
			},
			{
				displayName: 'Specify Headers As',
				name: 'specifyHeaders',
				type: 'options',
				options: [
					{ name: 'Key/Value Pairs', value: 'keypair' },
					{ name: 'Raw JSON', value: 'json' },
				],
				default: 'keypair',
				displayOptions: {
					show: {
						forwardHeaders: [true],
						resource: ['htmlAPI'],
					},
				},
			},
			{
				displayName: 'Headers (JSON)',
				name: 'jsonHeadersParameter',
				type: 'json',
				description: 'Please prefix headers with "Spb-"',
				default: '',
				displayOptions: {
					show: {
						forwardHeaders: [true],
						specifyHeaders: ['json'],
						resource: ['htmlAPI'],
					},
				},
			},
			{
				displayName: 'Headers (Key/Value)',
				name: 'headerParameters',
				type: 'fixedCollection',
				description: 'No need to prefix headers with "Spb-", we are already taking care of it here',
				typeOptions: {
					multipleValues: true,
				},
				default: {},
				placeholder: 'Add Header',
				options: [
					{
						name: 'header',
						displayName: 'Header',
						values: [
							{
								displayName: 'Name',
								name: 'name',
								type: 'string',
								default: '',
							},
							{
								displayName: 'Value',
								name: 'value',
								type: 'string',
								default: '',
							},
						],
					},
				],
				displayOptions: {
					show: {
						forwardHeaders: [true],
						specifyHeaders: ['keypair'],
						resource: ['htmlAPI'],
					},
				},
			},
			{
					displayName: 'Send Body',
					name: 'sendBody',
					type: 'boolean',
					default: false,
					description: 'Whether to send a body with the request',
					displayOptions: {
							show: {
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
			},
			{
					displayName: 'Body Content Type',
					name: 'bodyContentType',
					type: 'options',
					options: [
							{
									name: 'Form Urlencoded',
									value: 'formUrlencoded',
							},
							{
									name: 'JSON',
									value: 'json',
							},
							{
									name: 'Raw',
									value: 'raw',
							},
					],
					default: 'formUrlencoded',
					description: 'Content-Type to use to send body data',
					displayOptions: {
							show: {
									sendBody: [true],
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
			},
			{
					displayName: 'Body',
					name: 'bodyParameters',
					type: 'fixedCollection',
					typeOptions: {
							multipleValues: true,
					},
					placeholder: 'Add Parameter',
					default: {},
					displayOptions: {
							show: {
									bodyContentType: ['formUrlencoded'],
									sendBody: [true],
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
					options: [
							{
									name: 'parameter',
									displayName: 'Parameter',
									values: [
											{
													displayName: 'Name',
													name: 'name',
													type: 'string',
													default: '',
											},
											{
													displayName: 'Value',
													name: 'value',
													type: 'string',
													default: '',
											},
									],
							},
					],
			},
			{
					displayName: 'Body',
					name: 'jsonBodyParameter',
					type: 'json',
					default: '',
					displayOptions: {
							show: {
									bodyContentType: ['json'],
									sendBody: [true],
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
			},
			{
					displayName: 'Body',
					name: 'rawBodyParameter',
					type: 'string',
					typeOptions: {
							alwaysOpenEditWindow: true,
					},
					default: '',
					displayOptions: {
							show: {
									bodyContentType: ['raw'],
									sendBody: [true],
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
			},
			{
					displayName: 'Content-Type',
					name: 'rawContentType',
					type: 'string',
					default: 'text/plain',
					description: 'The Content-Type of the raw body',
					displayOptions: {
							show: {
									bodyContentType: ['raw'],
									sendBody: [true],
									resource: ['htmlAPI'],
									operation: ['post', 'put'],
							},
					},
			},
			{
				displayName: 'Search',
				description: 'Enter your search query',
				required: true,
				name: 'search',
				type: 'string',
				default: 'pizza',
				displayOptions: {
					show: {
						resource: ['googleSearchAPI'],
					},
				},
			},
			// Additional Fields for HTML API
			{
				displayName: 'Additional Fields',
				name: 'additionalFields',
				type: 'collection',
				default: {},
				placeholder: 'Add Field',
				displayOptions: {
					show: {
						resource: ['htmlAPI'],
					},
				},
				options: [
					{
						displayName: 'AI Data Extraction',
						name: 'aiExtractRules',
						type: 'json',
						default: '',
						description: 'Data extraction from description using AI',
					},
					{
						displayName: 'AI Query',
						name: 'aiQuery',
						type: 'string',
						default: '',
						description: 'The information you want to extract from the webpage using AI',
					},
					{
						displayName: 'AI Selector',
						name: 'aiSelector',
						type: 'string',
						default: '',
						description: 'CSS selector to focus the AI extraction on a specific part of the page',
					},
					{
						displayName: 'Block Ads',
						name: 'blockAds',
						type: 'boolean',
						default: false,
						description: 'Whether to block ads on the page you want to scrape or not',
					},
					{
						displayName: 'Block Resources',
						name: 'blockResources',
						type: 'boolean',
						default: true,
						description: 'Whether to block images and CSS on the page you want to scrape or not',
					},
					{
						displayName: 'Cookies',
						name: 'cookies',
						type: 'string',
						default: '',
						description: 'Pass custom cookies to the webpage you want to scrape',
						hint: 'name=value,other_attributes=other_attribues_value;',
					},
					{
						displayName: 'Country Code',
						name: 'countryCode',
						type: 'string',
						default: '',
						description: 'Premium proxy geolocation',
					},
					{
						displayName: 'Custom Google',
						name: 'customGoogle',
						type: 'boolean',
						default: false,
						description: 'Whether you are scraping Google domains or not? Set to true to scrape Google',
					},
					{
						displayName: 'Device',
						name: 'device',
						type: 'options',
						description: 'Control the device the request will be sent from',
						options: [
							{ name: 'Desktop', value: 'desktop' },
							{ name: 'Mobile', value: 'mobile' },
						],
						default: 'desktop',
					},
					{
						displayName: 'Extract Data',
						name: 'extractRules',
						type: 'json',
						default: '',
						description: 'Data extraction from CSS selectors',
					},
					{
						displayName: 'Forward Headers Pure',
						name: 'forwardHeadersPure',
						type: 'boolean',
						default: false,
						description: 'Whether to forward only particular headers to the webpage, and nothing else or not',
					},
					{
						displayName: 'JS Scenario',
						name: 'js_scenario',
						type: 'json',
						default: '',
						description: 'JavaScript scenario to execute',
					},
					{
						displayName: 'JSON Response',
						name: 'jsonResponse',
						type: 'boolean',
						default: false,
						description: 'Whether to wrap response in JSON or not',
					},
					{
						displayName: 'Own Proxy',
						name: 'ownProxy',
						type: 'string',
						default: '',
						description: 'Allows you to use ScrapingBee with your own proxy provider',
					},
					{
						displayName: 'Premium Proxy',
						name: 'premiumProxy',
						type: 'boolean',
						default: false,
						description: 'Whether to use premium proxies to bypass difficult to scrape websites or not',
					},
					{
						displayName: 'Render JS',
						name: 'renderJs',
						type: 'boolean',
						default: true,
						description: 'Whether to render the JavaScript on the page with a headless browser or not',
					},
					{
						displayName: 'Return Page Source',
						name: 'returnPageSource',
						type: 'boolean',
						default: false,
						description: 'Whether to return the original HTML before the JavaScript rendering or not',
					},
					{
						displayName: 'Scraping Configuration',
						name: 'scrapingConfig',
						type: 'string',
						default: '',
						description: 'Use a pre-saved request configuration on your request',
					},
					{
						displayName: 'Screenshot',
						name: 'screenshot',
						type: 'boolean',
						default: false,
						description: 'Whether to return a screenshot of the page you want to scrape or not',
					},
					{
						displayName: 'Screenshot Full Page',
						name: 'screenshotFullPage',
						type: 'boolean',
						default: false,
						description: 'Whether to Return a screenshot of the full page you want to scrape or not',
					},
					{
						displayName: 'Screenshot Selector',
						name: 'screenshotSelector',
						type: 'string',
						default: '',
						description: 'Return a screenshot of a particular area of the page, targeted by a CSS selector',
					},
					{
						displayName: 'Session ID',
						name: 'sessionId',
						type: 'number',
						default: '',
						description: 'Route multiple API requests through the same IP address',
					},
					{
						displayName: 'Stealth Proxy',
						name: 'stealthProxy',
						type: 'boolean',
						default: false,
						description: 'Whether to use special stealth proxy pool or not',
					},
					{
						displayName: 'Timeout',
						name: 'timeout',
						type: 'number',
						default: 140000,
						description: 'Timeout for your requests',
					},
					{
						displayName: 'Transparent Status Code',
						name: 'transparentStatusCode',
						type: 'boolean',
						default: false,
						description: 'Whether to transparently return the same HTTP code of the page requested or not',
					},
					{
						displayName: 'Wait',
						name: 'wait',
						type: 'number',
						default: '',
						description: 'Additional time in ms for JavaScript to render',
					},
					{
						displayName: 'Wait Browser',
						name: 'waitBrowser',
						type: 'options',
						description: 'Control the device the request will be sent from',
						options: [
							{ name: 'Domcontentloaded', value: 'domcontentloaded' },
							{ name: 'Load', value: 'load' },
							{ name: 'Networkidle0', value: 'networkidle0' },
							{ name: 'Networkidle2', value: 'networkidle2' },
						],
						default: 'domcontentloaded',
					},
					{
						displayName: 'Wait For',
						name: 'waitFor',
						type: 'string',
						default: '',
						description: 'CSS / XPath selector to wait for in the DOM',
					},
					{
						displayName: 'Window Height',
						name: 'windowHeight',
						type: 'number',
						default: 1080,
						description: 'Height, in pixel, of the viewport used to render the page you want to scrape',
					},
					{
						displayName: 'Window Width',
						name: 'windowWidth',
						type: 'number',
						default: 1920,
						description: 'Width, in pixel, of the viewport used to render the page you want to scrape',
					},
				],
			},
			// Additional Fields for Google Search API
			{
				displayName: 'Additional Fields',
				name: 'additionalFields',
				type: 'collection',
				default: {},
				placeholder: 'Add Field',
				displayOptions: {
					show: {
						resource: ['googleSearchAPI'],
					},
				},
				options: [
					{
						displayName: 'Add HTML',
						name: 'addHtml',
						type: 'boolean',
						default: false,
						description: 'Whether to add the full html of the page in the results or not',
					},
					{
						displayName: 'Country Code',
						name: 'countryCode',
						type: 'string',
						default: 'us',
						description: 'Country code from which you would like the request to come from',
					},
					{
						displayName: 'Device',
						name: 'device',
						type: 'options',
						description: 'Control the device the request will be sent from',
						options: [
							{ name: 'Desktop', value: 'desktop' },
							{ name: 'Mobile', value: 'mobile' },
						],
						default: 'desktop',
					},
					{
						displayName: 'Disable Autocorrection',
						name: 'nfpr',
						type: 'boolean',
						default: false,
						description: 'Whether to exclude results from auto-corrected queries that were spelt wrong or not',
					},
					{
						displayName: 'Extra Params',
						name: 'extraParams',
						type: 'string',
						default: '',
						description: 'Extra Google URL parameters',
						hint: 'You can also pass multiple parameters, separated by &: example: tbs=qdr:d&lr=lang_fr',
					},
					{
						displayName: 'Language',
						name: 'language',
						type: 'string',
						default: 'en',
						description: 'Language the search results will be displayed in',
					},
					{
						displayName: 'Number of Results',
						name: 'nbResults',
						type: 'number',
						default: 100,
						description: 'The number of results you want to get back from Google Search',
					},
					{
						displayName: 'Page',
						name: 'page',
						type: 'number',
						default: 1,
						description: 'The page number you want to extract results from',
					},
					{
						displayName: 'Search Type',
						name: 'searchType',
						type: 'options',
						description: 'The type of search you want to perform, (classic, news or maps)',
						options: [
							{ name: 'Classic', value: 'classic' },
							{ name: 'News', value: 'news' },
							{ name: 'Maps', value: 'maps' },
						],
						default: 'classic',
					},
				],
			},
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnData: INodeExecutionData[] = [];

		for (let i = 0; i < items.length; i++) {
			try {
				const resource = this.getNodeParameter('resource', i) as string;

				const headers: { [key: string]: string } = { 'User-Agent': 'n8n' };
				let endpoint = '';
				let requestMethod: 'GET' | 'POST' | 'PUT' = 'GET';

				const requestOptions: IHttpRequestOptions = {
					url: '',
					method: 'GET',
					headers,
					returnFullResponse: true,
					encoding: 'arraybuffer', // Always expect a buffer for any content type
					json: false, // We will handle the body manually
				};

				// All parameters for the ScrapingBee URL will be built here
				const scrapingBeeUrlParams: { [key: string]: any } = {};

				if (resource === 'htmlAPI') {
					endpoint = 'https://app.scrapingbee.com/api/v1/';
					requestMethod = (this.getNodeParameter('operation', i) as string).toUpperCase() as 'GET' | 'POST' | 'PUT';

					// Add base URL parameter
					scrapingBeeUrlParams.url = this.getNodeParameter('url', i) as string;

					// Add all Additional Fields (like 'screenshot') to the URL parameters
					const additionalFields = this.getNodeParameter('additionalFields', i, {}) as any;
					Object.keys(additionalFields).forEach(key => {
						const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
						if (additionalFields[key] !== '' && additionalFields[key] !== undefined && additionalFields[key] !== null) {
							scrapingBeeUrlParams[snakeKey] = additionalFields[key];
						}
					});

					const forwardHeaders = this.getNodeParameter('forwardHeaders', i, false) as boolean;
					if (forwardHeaders) {
						scrapingBeeUrlParams.forward_headers = true;
						const specifyHeaders = this.getNodeParameter('specifyHeaders', i, 'keypair') as string;
						if (specifyHeaders === 'json') {
							const jsonHeaders = this.getNodeParameter('jsonHeadersParameter', i, '') as string;
							if (jsonHeaders) Object.assign(headers, JSON.parse(jsonHeaders));
						} else {
							const headerParameters = this.getNodeParameter('headerParameters', i, { header: [] }) as { header: { name: string; value: string }[] };
							for (const header of headerParameters.header) {
								headers[`Spb-${header.name}`] = header.value;
							}
						}
					}

					requestOptions.method = requestMethod;

					if (requestMethod === 'POST' || requestMethod === 'PUT') {
						const sendBody = this.getNodeParameter('sendBody', i, false) as boolean;
						if (sendBody) {
							scrapingBeeUrlParams.forward_headers = true;
							let forwardedBody: string | Buffer = '';
							const bodyContentType = this.getNodeParameter('bodyContentType', i, 'formUrlencoded') as string;

							if (bodyContentType === 'formUrlencoded') {
								const bodyParameters = this.getNodeParameter('bodyParameters', i, { parameter: [] }) as { parameter: { name: string; value: string }[] };
								const urlSearchParams = new URLSearchParams();
								for (const param of bodyParameters.parameter) {
									urlSearchParams.append(param.name, param.value);
								}
								forwardedBody = urlSearchParams.toString();
								headers['Spb-Content-Type'] = 'application/x-www-form-urlencoded';
							} else if (bodyContentType === 'json') {
								forwardedBody = this.getNodeParameter('jsonBodyParameter', i, '') as string;
								headers['Spb-Content-Type'] = 'application/json';
							} else if (bodyContentType === 'raw') {
								forwardedBody = this.getNodeParameter('rawBodyParameter', i, '') as string;
								headers['Spb-Content-Type'] = this.getNodeParameter('rawContentType', i, 'text/plain') as string;
							}

							// The body of the request to ScrapingBee is the exact body for the target
							requestOptions.body = forwardedBody;
						}
					}
				} else if (resource === 'googleSearchAPI') {
					endpoint = 'https://app.scrapingbee.com/api/v1/store/google';
					requestOptions.method = 'GET';
					scrapingBeeUrlParams.search = this.getNodeParameter('search', i) as string;
					const additionalFields = this.getNodeParameter('additionalFields', i, {}) as any;
					Object.keys(additionalFields).forEach(key => {
						const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
						if (additionalFields[key] !== '' && additionalFields[key] !== undefined && additionalFields[key] !== null) {
							scrapingBeeUrlParams[snakeKey] = additionalFields[key];
						}
					});
				} else { // usage
					endpoint = 'https://app.scrapingbee.com/api/v1/usage';
					requestOptions.method = 'GET';
				}

				// Assign all collected URL parameters and the final URL to the request options
				requestOptions.url = endpoint;
				requestOptions.qs = scrapingBeeUrlParams;

				const response = await this.helpers.httpRequestWithAuthentication.call(
					this,
					'ScrapingBeeApi',
					requestOptions,
				);
				const contentType = (response.headers['content-type'] || '').split(';')[0];
				const responseBody = Buffer.from(response.body);

				if (contentType.includes('application/json')) {
					try {
						const jsonData = JSON.parse(responseBody.toString());
						returnData.push({ json: jsonData, pairedItem: { item: i } });
					} catch (parseError) {
						returnData.push({ json: { raw: responseBody.toString() }, pairedItem: { item: i } });
					}
				} else if (contentType.startsWith('text/')) {
					returnData.push({ json: { data: responseBody.toString() }, pairedItem: { item: i } });
				} else {
					const contentDisposition = response.headers['content-disposition'];
					let fileName = '';
					let directory = '';

					if (contentDisposition) {
						const match = contentDisposition.match(/filename="?([^"]+)"?/);
						if (match) {
							fileName = match[1];
						}
					}

					if (!fileName && requestOptions.qs?.url) {
						try {
							const url = new URL(requestOptions.qs.url as string);
							const pathParts = url.pathname.split('/').filter(p => p);
							fileName = pathParts.pop() || '';
							directory = pathParts.join('/');
						} catch (e) { /* ignore invalid URLs */ }
					}

					if (!fileName) {
						const extension = (contentType.split('/')[1] || 'bin').split('+')[0];
						fileName = `scrapingbee-data-${Date.now()}.${extension}`;
					}

					const binaryData = await this.helpers.prepareBinaryData(responseBody, fileName, contentType);

					returnData.push({
						json: { directory },
						binary: { data: binaryData },
						pairedItem: { item: i },
					});
				}
			} catch (error) {
				if (this.continueOnFail()) {
					let errorMessage = error.message;
					if (error.response?.body) {
						try {
							const apiError = JSON.parse(error.response.body.toString());
							errorMessage = apiError.message || apiError.detail || JSON.stringify(apiError);
						} catch (e) {
							errorMessage = error.response.body.toString();
						}
					}
					returnData.push({ json: { error: errorMessage }, pairedItem: { item: i } });
					continue;
				}
				throw new NodeOperationError(this.getNode(), error);
			}
		}

		return [this.helpers.returnJsonArray(returnData)];
	}
}
